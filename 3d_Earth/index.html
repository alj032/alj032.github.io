<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D World Map with GPS Tracking</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #controls h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4CAF50;
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        
        select, input[type="range"], button, input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #gpsStatus {
            padding: 10px;
            background: rgba(255, 0, 0, 0.2);
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            text-align: center;
        }
        
        #gpsStatus.active {
            background: rgba(76, 175, 80, 0.2);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .button-group button {
            padding: 6px;
            font-size: 12px;
        }
        
        #trackingStats {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        #trackingStats div {
            margin-bottom: 5px;
        }
        
        .export-options {
            display: none;
            margin-top: 10px;
        }
        
        .export-options.show {
            display: block;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading World Map...</div>
        <div class="spinner"></div>
    </div>
    
    <div id="container"></div>
    <div id="tooltip" class="tooltip"></div>
    
    <div id="controls">
        <h3>üåç World Map Controls</h3>
        
        <div class="control-group">
            <label>Base Map</label>
            <select id="basemap">
                <option value="realistic">Realistic Earth</option>
                <option value="political">Political</option>
                <option value="topographic">Topographic</option>
                <option value="night">Night Lights</option>
                <option value="clouds">With Clouds</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Layers</label>
            <div class="checkbox-group">
                <input type="checkbox" id="borders" checked>
                <label for="borders">Country Borders</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="cities">
                <label for="cities">Major Cities</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="grid">
                <label for="grid">Lat/Lon Grid</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="atmosphere" checked>
                <label for="atmosphere">Atmosphere</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="clouds">
                <label for="clouds">Cloud Layer</label>
            </div>
        </div>
        
        <div class="control-group">
            <label>GPS Tracking</label>
            <div id="gpsStatus">GPS Inactive</div>
            <button id="startTracking">Start GPS Tracking</button>
            <button id="stopTracking" disabled>Stop Tracking</button>
            
            <div id="trackingStats" style="display:none;">
                <div>Points: <span id="pointCount">0</span></div>
                <div>Distance: <span id="totalDistance">0</span> km</div>
                <div>Duration: <span id="duration">00:00:00</span></div>
            </div>
            
            <div class="button-group">
                <button id="clearPath" disabled>Clear Path</button>
                <button id="centerOnLocation" disabled>Center View</button>
            </div>
            
            <button id="exportPath" disabled>Export Path</button>
            <div class="export-options" id="exportOptions">
                <select id="exportFormat">
                    <option value="geojson">GeoJSON</option>
                    <option value="gpx">GPX</option>
                    <option value="kml">KML</option>
                    <option value="csv">CSV</option>
                </select>
                <input type="text" id="routeName" placeholder="Route name (optional)">
                <button id="downloadExport">Download</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>Rotation Speed</label>
            <input type="range" id="rotationSpeed" min="0" max="100" value="10">
        </div>
        
        <div class="control-group">
            <button id="resetView">Reset View</button>
        </div>
    </div>
    
    <div id="info">
        <div>Left click + drag: Rotate</div>
        <div>Right click + drag: Pan</div>
        <div>Scroll: Zoom</div>
        <div>Click cities/points for info</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, globe, atmosphere, clouds;
        let borders, cities, grid;
        let rotationSpeed = 0.001;
        let autoRotate = true;
        let mouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // GPS Tracking variables
        let isTracking = false;
        let gpsPath = [];
        let pathLine = null;
        let currentLocationMarker = null;
        let watchId = null;
        let trackingStartTime = null;
        let trackingInterval = null;
        
        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = 'anonymous';
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Add stars background
            createStarfield();
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 2.5;
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
            
            // Create globe with realistic texture
            createGlobe();
            
            // Create layers
            createBorders();
            createCities();
            createGrid();
            createAtmosphere();
            createClouds();
            
            // Event listeners
            setupEventListeners();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            
            // Start animation
            animate();
        }
        
        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                sizeAttenuation: false
            });
            
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        
        function createGlobe() {
            const geometry = new THREE.SphereGeometry(1, 128, 128);
            
            // Create realistic Earth texture
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Create a realistic Earth-like texture
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            
            // Ocean base
            ctx.fillStyle = '#1e3a5f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add continents (simplified world map)
            ctx.fillStyle = '#2d5016';
            
            // Africa
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.55, canvas.height * 0.6, 80, 120, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Europe
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.52, canvas.height * 0.35, 60, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Asia
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.7, canvas.height * 0.35, 150, 80, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // North America
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.25, canvas.height * 0.35, 100, 80, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // South America
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.3, canvas.height * 0.7, 50, 100, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Australia
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.8, canvas.height * 0.75, 60, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Add texture details
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 10;
                const opacity = Math.random() * 0.3;
                
                ctx.fillStyle = `rgba(139, 195, 74, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ice caps
            ctx.fillStyle = '#e8f5e9';
            ctx.fillRect(0, 0, canvas.width, 50);
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            
            // Add noise for realism
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 20;
                data[i] += noise;
                data[i + 1] += noise;
                data[i + 2] += noise;
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            // Create bump map
            const bumpCanvas = document.createElement('canvas');
            bumpCanvas.width = 1024;
            bumpCanvas.height = 512;
            const bumpCtx = bumpCanvas.getContext('2d');
            bumpCtx.filter = 'blur(2px)';
            bumpCtx.drawImage(canvas, 0, 0, bumpCanvas.width, bumpCanvas.height);
            const bumpTexture = new THREE.CanvasTexture(bumpCanvas);
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                bumpMap: bumpTexture,
                bumpScale: 0.02,
                specularMap: createSpecularMap(),
                specular: new THREE.Color('grey'),
                shininess: 10
            });
            
            globe = new THREE.Mesh(geometry, material);
            globe.castShadow = true;
            globe.receiveShadow = true;
            scene.add(globe);
        }
        
        function createSpecularMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Dark for land, bright for water (inverse of land)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dark areas for land
            ctx.fillStyle = '#000000';
            
            // Continents (matching globe texture positions)
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.55, canvas.height * 0.6, 80, 120, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.52, canvas.height * 0.35, 60, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.7, canvas.height * 0.35, 150, 80, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.25, canvas.height * 0.35, 100, 80, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.3, canvas.height * 0.7, 50, 100, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(canvas.width * 0.8, canvas.height * 0.75, 60, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        function createBorders() {
            const geometry = new THREE.SphereGeometry(1.005, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffeb3b,
                wireframe: true,
                opacity: 0.2,
                transparent: true
            });
            
            borders = new THREE.Mesh(geometry, material);
            scene.add(borders);
        }
        
        function createCities() {
            cities = new THREE.Group();
            
            // Major cities with coordinates
            const cityData = [
                { lat: 40.7128, lon: -74.0060, name: 'New York', population: '8.3M' },
                { lat: 51.5074, lon: -0.1278, name: 'London', population: '9.0M' },
                { lat: 35.6762, lon: 139.6503, name: 'Tokyo', population: '37.4M' },
                { lat: -33.8688, lon: 151.2093, name: 'Sydney', population: '5.3M' },
                { lat: 48.8566, lon: 2.3522, name: 'Paris', population: '2.1M' },
                { lat: 55.7558, lon: 37.6173, name: 'Moscow', population: '12.5M' },
                { lat: 39.9042, lon: 116.4074, name: 'Beijing', population: '21.5M' },
                { lat: -23.5505, lon: -46.6333, name: 'S√£o Paulo', population: '12.3M' },
                { lat: 19.4326, lon: -99.1332, name: 'Mexico City', population: '9.2M' },
                { lat: 30.0444, lon: 31.2357, name: 'Cairo', population: '20.4M' }
            ];
            
            cityData.forEach(city => {
                const position = latLonToVector3(city.lat, city.lon, 1.01);
                
                // City marker
                const geometry = new THREE.SphereGeometry(0.008, 16, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff5722,
                    emissive: 0xff5722,
                    emissiveIntensity: 0.5
                });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.copy(position);
                marker.userData = city;
                
                cities.add(marker);
                
                // Add glow effect
                const glowGeometry = new THREE.SphereGeometry(0.015, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff5722,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                cities.add(glow);
            });
            
            cities.visible = false;
            scene.add(cities);
        }
        
        function createGrid() {
            grid = new THREE.Group();
            
            // Latitude lines
            for (let lat = -80; lat <= 80; lat += 10) {
                const points = [];
                for (let lon = 0; lon <= 360; lon += 5) {
                    const position = latLonToVector3(lat, lon - 180, 1.005);
                    points.push(position);
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: lat === 0 ? 0x00ff00 : 0x444444,
                    opacity: lat === 0 ? 0.6 : 0.3,
                    transparent: true
                });
                
                const line = new THREE.Line(geometry, material);
                grid.add(line);
            }
            
            // Longitude lines
            for (let lon = 0; lon < 360; lon += 10) {
                const points = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const position = latLonToVector3(lat, lon - 180, 1.005);
                    points.push(position);
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: lon === 180 ? 0x00ff00 : 0x444444,
                    opacity: lon === 180 ? 0.6 : 0.3,
                    transparent: true
                });
                
                const line = new THREE.Line(geometry, material);
                grid.add(line);
            }
            
            grid.visible = false;
            scene.add(grid);
        }
        
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(1.1, 64, 64);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    c: { type: "f", value: 0.3 },
                    p: { type: "f", value: 5.0 },
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float c;
                    uniform float p;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(c - dot(vNormal, vec3(0, 0, 1.0)), p);
                        gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }
        
        function createClouds() {
            const geometry = new THREE.SphereGeometry(1.02, 64, 64);
            
            // Create cloud texture
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Create cloud patterns
            ctx.fillStyle = 'rgba(255, 255, 255, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add cloud formations
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 30 + 10;
                const opacity = Math.random() * 0.3 + 0.1;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            clouds = new THREE.Mesh(geometry, material);
            clouds.visible = false;
            scene.add(clouds);
        }
        
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lon + 180) * Math.PI / 180;
            
            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }
        
        function vector3ToLatLon(vector) {
            const radius = vector.length();
            const lat = 90 - (Math.acos(vector.y / radius) * 180 / Math.PI);
            const lon = ((Math.atan2(vector.z, -vector.x) * 180 / Math.PI) + 180) % 360 - 180;
            return { lat, lon };
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function updateGPSPath() {
            if (pathLine) {
                scene.remove(pathLine);
            }
            
            if (gpsPath.length > 1) {
                const points = gpsPath.map(point => 
                    latLonToVector3(point.lat, point.lon, 1.01)
                );
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    linewidth: 3,
                    opacity: 0.8,
                    transparent: true
                });
                
                pathLine = new THREE.Line(geometry, material);
                scene.add(pathLine);
            }
            
            // Update current location marker
            if (gpsPath.length > 0 && currentLocationMarker) {
                const lastPoint = gpsPath[gpsPath.length - 1];
                const position = latLonToVector3(lastPoint.lat, lastPoint.lon, 1.015);
                currentLocationMarker.position.copy(position);
            }
        }
        
        function startGPSTracking() {
            if (!navigator.geolocation) {
                alert('Geolocation is not supported by your browser');
                return;
            }
            
            isTracking = true;
            trackingStartTime = Date.now();
            document.getElementById('startTracking').disabled = true;
            document.getElementById('stopTracking').disabled = false;
            document.getElementById('clearPath').disabled = false;
            document.getElementById('centerOnLocation').disabled = false;
            document.getElementById('exportPath').disabled = false;
            document.getElementById('gpsStatus').textContent = 'GPS Active';
            document.getElementById('gpsStatus').classList.add('active');
            document.getElementById('trackingStats').style.display = 'block';
            
            // Create current location marker
            const geometry = new THREE.SphereGeometry(0.01, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5
            });
            currentLocationMarker = new THREE.Mesh(geometry, material);
            scene.add(currentLocationMarker);
            
            // Start tracking
            watchId = navigator.geolocation.watchPosition(
                position => {
                    const point = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude,
                        timestamp: Date.now(),
                        altitude: position.coords.altitude,
                        accuracy: position.coords.accuracy
                    };
                    
                    gpsPath.push(point);
                    updateGPSPath();
                    updateTrackingStats();
                    
                    // Auto center on first point
                    if (gpsPath.length === 1) {
                        centerOnLocation();
                    }
                },
                error => {
                    console.error('GPS Error:', error);
                    document.getElementById('gpsStatus').textContent = 'GPS Error: ' + error.message;
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 5000
                }
            );
            
            // Update duration
            trackingInterval = setInterval(updateTrackingStats, 1000);
        }
        
        function stopGPSTracking() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            if (trackingInterval) {
                clearInterval(trackingInterval);
                trackingInterval = null;
            }
            
            isTracking = false;
            document.getElementById('startTracking').disabled = false;
            document.getElementById('stopTracking').disabled = true;
            document.getElementById('gpsStatus').textContent = 'GPS Inactive';
            document.getElementById('gpsStatus').classList.remove('active');
        }
        
        function clearGPSPath() {
            gpsPath = [];
            if (pathLine) {
                scene.remove(pathLine);
                pathLine = null;
            }
            if (currentLocationMarker) {
                scene.remove(currentLocationMarker);
                currentLocationMarker = null;
            }
            document.getElementById('clearPath').disabled = true;
            document.getElementById('exportPath').disabled = true;
            document.getElementById('trackingStats').style.display = 'none';
        }
        
        function centerOnLocation() {
            if (gpsPath.length > 0) {
                const lastPoint = gpsPath[gpsPath.length - 1];
                const position = latLonToVector3(lastPoint.lat, lastPoint.lon, 1);
                
                // Rotate globe to show location
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 0, 1),
                    position.clone().normalize()
                );
                
                globe.quaternion.slerp(quaternion, 0.5);
                if (borders) borders.quaternion.copy(globe.quaternion);
                if (cities) cities.quaternion.copy(globe.quaternion);
                if (grid) grid.quaternion.copy(globe.quaternion);
                if (clouds) clouds.quaternion.copy(globe.quaternion);
                
                autoRotate = false;
            }
        }
        
        function updateTrackingStats() {
            document.getElementById('pointCount').textContent = gpsPath.length;
            
            // Calculate total distance
            let totalDistance = 0;
            for (let i = 1; i < gpsPath.length; i++) {
                totalDistance += calculateDistance(
                    gpsPath[i-1].lat, gpsPath[i-1].lon,
                    gpsPath[i].lat, gpsPath[i].lon
                );
            }
            document.getElementById('totalDistance').textContent = totalDistance.toFixed(2);
            
            // Update duration
            if (trackingStartTime) {
                const duration = Date.now() - trackingStartTime;
                const hours = Math.floor(duration / 3600000);
                const minutes = Math.floor((duration % 3600000) / 60000);
                const seconds = Math.floor((duration % 60000) / 1000);
                document.getElementById('duration').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        function exportPath() {
            document.getElementById('exportOptions').classList.toggle('show');
        }
        
        function downloadExport() {
            const format = document.getElementById('exportFormat').value;
            const routeName = document.getElementById('routeName').value || 'GPS Route';
            let content = '';
            let filename = '';
            let mimeType = '';
            
            switch (format) {
                case 'geojson':
                    content = exportGeoJSON(routeName);
                    filename = `${routeName.replace(/\s+/g, '_')}.geojson`;
                    mimeType = 'application/json';
                    break;
                case 'gpx':
                    content = exportGPX(routeName);
                    filename = `${routeName.replace(/\s+/g, '_')}.gpx`;
                    mimeType = 'application/gpx+xml';
                    break;
                case 'kml':
                    content = exportKML(routeName);
                    filename = `${routeName.replace(/\s+/g, '_')}.kml`;
                    mimeType = 'application/vnd.google-earth.kml+xml';
                    break;
                case 'csv':
                    content = exportCSV();
                    filename = `${routeName.replace(/\s+/g, '_')}.csv`;
                    mimeType = 'text/csv';
                    break;
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            document.getElementById('exportOptions').classList.remove('show');
        }
        
        function exportGeoJSON(name) {
            const features = [{
                type: 'Feature',
                properties: {
                    name: name,
                    points: gpsPath.length,
                    distance: parseFloat(document.getElementById('totalDistance').textContent),
                    duration: document.getElementById('duration').textContent
                },
                geometry: {
                    type: 'LineString',
                    coordinates: gpsPath.map(point => [point.lon, point.lat, point.altitude || 0])
                }
            }];
            
            return JSON.stringify({
                type: 'FeatureCollection',
                features: features
            }, null, 2);
        }
        
        function exportGPX(name) {
            const points = gpsPath.map(point => {
                const date = new Date(point.timestamp).toISOString();
                return `    <trkpt lat="${point.lat}" lon="${point.lon}">
      ${point.altitude ? `<ele>${point.altitude}</ele>` : ''}
      <time>${date}</time>
    </trkpt>`;
            }).join('\n');
            
            return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="3D World Map GPS Tracker">
  <trk>
    <name>${name}</name>
    <trkseg>
${points}
    </trkseg>
  </trk>
</gpx>`;
        }
        
        function exportKML(name) {
            const coordinates = gpsPath.map(point => 
                `${point.lon},${point.lat},${point.altitude || 0}`
            ).join(' ');
            
            return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Placemark>
      <name>${name}</name>
      <LineString>
        <coordinates>${coordinates}</coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>`;
        }
        
        function exportCSV() {
            const headers = 'Latitude,Longitude,Altitude,Timestamp,Accuracy\n';
            const rows = gpsPath.map(point => 
                `${point.lat},${point.lon},${point.altitude || ''},${new Date(point.timestamp).toISOString()},${point.accuracy || ''}`
            ).join('\n');
            
            return headers + rows;
        }
        
        function setupEventListeners() {
            // Mouse controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('click', onClick);
            
            // Touch controls
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Control panel
            document.getElementById('basemap').addEventListener('change', changeBasemap);
            document.getElementById('borders').addEventListener('change', toggleBorders);
            document.getElementById('cities').addEventListener('change', toggleCities);
            document.getElementById('grid').addEventListener('change', toggleGrid);
            document.getElementById('atmosphere').addEventListener('change', toggleAtmosphere);
            document.getElementById('clouds').addEventListener('change', toggleClouds);
            document.getElementById('rotationSpeed').addEventListener('input', changeRotationSpeed);
            document.getElementById('resetView').addEventListener('click', resetView);
            
            // GPS controls
            document.getElementById('startTracking').addEventListener('click', startGPSTracking);
            document.getElementById('stopTracking').addEventListener('click', stopGPSTracking);
            document.getElementById('clearPath').addEventListener('click', clearGPSPath);
            document.getElementById('centerOnLocation').addEventListener('click', centerOnLocation);
            document.getElementById('exportPath').addEventListener('click', exportPath);
            document.getElementById('downloadExport').addEventListener('click', downloadExport);
        }
        
        function onMouseDown(event) {
            mouseDown = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
            autoRotate = false;
        }
        
        function onMouseUp() {
            mouseDown = false;
        }
        
        function onMouseMove(event) {
            if (!mouseDown) {
                // Update mouse position for raycasting
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                return;
            }
            
            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };
            
            if (event.buttons === 1) { // Left click - rotate
                const rotationQuaternion = new THREE.Quaternion();
                const axis = new THREE.Vector3(deltaMove.y, deltaMove.x, 0).normalize();
                rotationQuaternion.setFromAxisAngle(axis, Math.sqrt(deltaMove.x * deltaMove.x + deltaMove.y * deltaMove.y) * 0.01);
                
                globe.quaternion.multiplyQuaternions(rotationQuaternion, globe.quaternion);
                
                // Apply same rotation to overlays
                if (borders) borders.quaternion.copy(globe.quaternion);
                if (cities) cities.quaternion.copy(globe.quaternion);
                if (grid) grid.quaternion.copy(globe.quaternion);
                if (clouds) clouds.quaternion.copy(globe.quaternion);
                if (pathLine) pathLine.quaternion.copy(globe.quaternion);
                if (currentLocationMarker) currentLocationMarker.quaternion.copy(globe.quaternion);
            } else if (event.buttons === 2) { // Right click - pan
                camera.position.x -= deltaMove.x * 0.01;
                camera.position.y += deltaMove.y * 0.01;
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            if (cities && cities.visible) {
                const intersects = raycaster.intersectObjects(cities.children);
                
                if (intersects.length > 0) {
                    const city = intersects[0].object.userData;
                    if (city && city.name) {
                        const tooltip = document.getElementById('tooltip');
                        tooltip.innerHTML = `<strong>${city.name}</strong><br>Population: ${city.population}`;
                        tooltip.style.display = 'block';
                        tooltip.style.left = event.clientX + 10 + 'px';
                        tooltip.style.top = event.clientY - 30 + 'px';
                        
                        setTimeout(() => {
                            tooltip.style.display = 'none';
                        }, 3000);
                    }
                }
            }
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            const zoom = camera.position.z - event.deltaY * 0.001;
            camera.position.z = Math.max(1.5, Math.min(5, zoom));
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                mouseDown = true;
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
                autoRotate = false;
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && mouseDown) {
                const deltaMove = {
                    x: event.touches[0].clientX - previousMousePosition.x,
                    y: event.touches[0].clientY - previousMousePosition.y
                };
                
                const rotationQuaternion = new THREE.Quaternion();
                const axis = new THREE.Vector3(deltaMove.y, deltaMove.x, 0).normalize();
                rotationQuaternion.setFromAxisAngle(axis, Math.sqrt(deltaMove.x * deltaMove.x + deltaMove.y * deltaMove.y) * 0.01);
                
                globe.quaternion.multiplyQuaternions(rotationQuaternion, globe.quaternion);
                
                // Apply same rotation to overlays
                if (borders) borders.quaternion.copy(globe.quaternion);
                if (cities) cities.quaternion.copy(globe.quaternion);
                if (grid) grid.quaternion.copy(globe.quaternion);
                if (clouds) clouds.quaternion.copy(globe.quaternion);
                if (pathLine) pathLine.quaternion.copy(globe.quaternion);
                if (currentLocationMarker) currentLocationMarker.quaternion.copy(globe.quaternion);
                
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function changeBasemap(event) {
            const basemap = event.target.value;
            
            // Create different texture styles
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            switch (basemap) {
                case 'realistic':
                    // Already created in createGlobe
                    location.reload(); // Simplest way to reset to default
                    break;
                case 'political':
                    ctx.fillStyle = '#1565C0';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    // Add country-colored regions
                    const colors = ['#e53935', '#43a047', '#fb8c00', '#8e24aa', '#00acc1'];
                    for (let i = 0; i < 50; i++) {
                        ctx.fillStyle = colors[i % colors.length];
                        ctx.beginPath();
                        ctx.arc(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            Math.random() * 100 + 50,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                    break;
                case 'topographic':
                    // Height-based coloring
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.2, '#8d6e63');
                    gradient.addColorStop(0.5, '#4caf50');
                    gradient.addColorStop(0.8, '#1976d2');
                    gradient.addColorStop(1, '#0d47a1');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    break;
                case 'night':
                    // Dark with city lights
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    // Add city lights
                    for (let i = 0; i < 1000; i++) {
                        const brightness = Math.random();
                        ctx.fillStyle = `rgba(255, 255, 200, ${brightness})`;
                        ctx.beginPath();
                        ctx.arc(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            Math.random() * 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                    break;
                case 'clouds':
                    // Show cloud layer prominently
                    document.getElementById('clouds').checked = true;
                    clouds.visible = true;
                    return;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            globe.material.map = texture;
            globe.material.needsUpdate = true;
        }
        
        function toggleBorders(event) {
            borders.visible = event.target.checked;
        }
        
        function toggleCities(event) {
            cities.visible = event.target.checked;
        }
        
        function toggleGrid(event) {
            grid.visible = event.target.checked;
        }
        
        function toggleAtmosphere(event) {
            atmosphere.visible = event.target.checked;
        }
        
        function toggleClouds(event) {
            clouds.visible = event.target.checked;
        }
        
        function changeRotationSpeed(event) {
            rotationSpeed = event.target.value / 10000;
            if (event.target.value > 0) {
                autoRotate = true;
            } else {
                autoRotate = false;
            }
        }
        
        function resetView() {
            camera.position.set(0, 0, 2.5);
            globe.quaternion.set(0, 0, 0, 1);
            if (borders) borders.quaternion.set(0, 0, 0, 1);
            if (cities) cities.quaternion.set(0, 0, 0, 1);
            if (grid) grid.quaternion.set(0, 0, 0, 1);
            if (clouds) clouds.quaternion.set(0, 0, 0, 1);
            if (pathLine) pathLine.quaternion.set(0, 0, 0, 1);
            if (currentLocationMarker) currentLocationMarker.quaternion.set(0, 0, 0, 1);
            autoRotate = true;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                const rotation = new THREE.Quaternion();
                rotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed);
                
                globe.quaternion.multiplyQuaternions(rotation, globe.quaternion);
                if (borders) borders.quaternion.copy(globe.quaternion);
                if (cities) cities.quaternion.copy(globe.quaternion);
                if (grid) grid.quaternion.copy(globe.quaternion);
                if (clouds) clouds.quaternion.copy(globe.quaternion);
                if (pathLine) pathLine.quaternion.copy(globe.quaternion);
                if (currentLocationMarker) currentLocationMarker.quaternion.copy(globe.quaternion);
            }
            
            // Rotate clouds slightly faster
            if (clouds && clouds.visible) {
                const cloudRotation = new THREE.Quaternion();
                cloudRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed * 0.3);
                clouds.quaternion.multiplyQuaternions(cloudRotation, clouds.quaternion);
            }
            
            // Pulse current location marker
            if (currentLocationMarker && currentLocationMarker.visible !== false) {
                const scale = 1 + Math.sin(Date.now() * 0.003) * 0.2;
                currentLocationMarker.scale.set(scale, scale, scale);
            }
            
            renderer.render(scene, camera);
        }
        
        // Prevent right-click context menu
        document.addEventListener('contextmenu', event => event.preventDefault());
        
        // Initialize the scene
        init();
    </script>
</body>
</html>