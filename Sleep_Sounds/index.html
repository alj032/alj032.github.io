<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .timer-container {
            text-align: center;
            margin: 20px auto;
            max-width: 300px;
        }

        .volume-info {
            text-align: center;
            margin: 10px auto 20px;
            max-width: 400px;
            font-size: 0.9em;
            color: #888;
            line-height: 1.4;
        }

        .timer-select {
            background: #2d2d2d;
            color: white;
            padding: 10px;
            border: none;
            border-radius: 5px;
            width: 100%;
            margin-top: 10px;
        }

        .sound-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .sound-card {
            background: #2d2d2d;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

            .sound-card:hover {
                transform: translateY(-5px);
                background: #3d3d3d;
            }

            .sound-card.playing {
                background: #4a4a4a;
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            }

        .sound-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .volume-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(45, 45, 45, 0.9);
            padding: 15px 25px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .volume-slider {
            width: 200px;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #666;
            border-radius: 2px;
            position: relative;
        }

            .volume-slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 15px;
                height: 15px;
                background: #fff;
                border-radius: 50%;
                cursor: pointer;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }

            .volume-slider::-moz-range-thumb {
                width: 15px;
                height: 15px;
                background: #fff;
                border-radius: 50%;
                cursor: pointer;
                border: none;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }

        .volume-label {
            font-size: 0.9em;
            opacity: 0.8;
            min-width: 30px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .sound-grid {
                grid-template-columns: 1fr;
            }
            
            .volume-container {
                padding: 20px;
                border-radius: 20px;
                bottom: 15px;
            }
            
            .volume-slider {
                width: 150px;
            }
            
            .volume-info {
                font-size: 0.8em;
                padding: 0 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Sleep Sounds</h1>
    </div>

    <div class="timer-container">
        <select id="timer" class="timer-select">
            <option value="0">Continuous</option>
            <option value="900">15 Minutes</option>
            <option value="1800">30 Minutes</option>
            <option value="3600">1 Hour</option>
            <option value="7200">2 Hours</option>
        </select>
    </div>

    <div class="volume-info">
        ðŸ’¡ Volume works relative to your device's volume setting. Use your device's volume buttons for overall loudness.
    </div>

    <div class="sound-grid" id="soundGrid"></div>

    <div class="volume-container">
        <span>ðŸ”‰</span>
        <input type="range" class="volume-slider" id="masterVolume" min="0" max="1" step="0.01" value="0.8">
        <span class="volume-label" id="volumeLabel">80%</span>
    </div>

    <script>
        // Sound definitions
        const sounds = [
            { name: 'White Noise', icon: 'ðŸŒŠ', file: 'white-noise.mp3' },
            { name: 'Rain', icon: 'ðŸŒ§', file: 'rain.mp3' },
            { name: 'Ocean', icon: 'ðŸŒŠ', file: 'ocean.mp3' },
            { name: 'Fan', icon: 'ðŸ’¨', file: 'fan.mp3' },
            { name: 'Forest', icon: 'ðŸŒ³', file: 'forest.mp3' },
            { name: 'Stream', icon: 'ðŸ’§', file: 'stream.mp3' }
        ];

        // Audio variables
        let audioContext = null;
        let audioBuffers = {};
        let activeSound = null;
        let timerTimeout = null;
        let gainNode = null;

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create master volume control
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);

                // Set initial volume from saved preference or default
                const savedVolume = localStorage.getItem('sleepSoundsVolume');
                const volumeValue = savedVolume ? parseFloat(savedVolume) : 0.8;
                gainNode.gain.value = volumeValue;
                
                // Update the slider and display if they exist
                const masterVolumeSlider = document.getElementById('masterVolume');
                if (masterVolumeSlider) {
                    masterVolumeSlider.value = volumeValue;
                    updateVolumeDisplay(volumeValue);
                }

                // Load all sound files
                preloadSounds();
            }

            // Ensure audio context is running
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            return audioContext;
        }

        // Preload and decode all sound files
        function preloadSounds() {
            sounds.forEach(sound => {
                fetch(`sounds/${sound.file}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        return audioContext.decodeAudioData(arrayBuffer);
                    })
                    .then(audioBuffer => {
                        audioBuffers[sound.file] = audioBuffer;
                    })
                    .catch(error => {
                        console.error(`Error loading sound: ${sound.file}`, error);
                    });
            });
        }

        // Play a sound with seamless looping
        function playSound(soundFile) {
            if (!audioContext) initAudioContext();

            // Ensure audio context is running
            if (audioContext.state !== 'running') {
                audioContext.resume();
            }

            // Stop currently playing sound if any
            if (activeSound) {
                activeSound.source.stop();
                activeSound = null;
            }

            // Check if the buffer is loaded
            const buffer = audioBuffers[soundFile];
            if (!buffer) {
                return null;
            }

            // Create and configure source
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            // Connect to the gain node (volume control)
            source.connect(gainNode);

            // Start playback
            const startTime = audioContext.currentTime;
            source.start(startTime);

            return { source, file: soundFile, startTime };
        }

        // Create sound cards
        function createSoundCard(sound) {
            const card = document.createElement('div');
            card.className = 'sound-card';
            card.innerHTML = `
            <div class="sound-icon">${sound.icon}</div>
            <div>${sound.name}</div>
          `;

            card.addEventListener('click', () => {
                // Initialize audio context on first click
                if (!audioContext) initAudioContext();

                // Handle click behavior
                if (activeSound && activeSound.file === sound.file) {
                    // Stop the sound if it's already playing
                    activeSound.source.stop();
                    activeSound = null;
                    card.classList.remove('playing');
                    clearTimeout(timerTimeout);
                } else {
                    // Remove playing state from all cards
                    document.querySelectorAll('.sound-card').forEach(c => {
                        c.classList.remove('playing');
                    });

                    // Play the new sound
                    activeSound = playSound(sound.file);
                    if (activeSound) {
                        card.classList.add('playing');
                        startTimer();
                    }
                }
            });

            return card;
        }

        // Timer functionality
        function startTimer() {
            clearTimeout(timerTimeout);
            const duration = parseInt(document.getElementById('timer').value);

            if (duration > 0 && activeSound) {
                timerTimeout = setTimeout(() => {
                    if (activeSound) {
                        activeSound.source.stop();
                        activeSound = null;
                        document.querySelector('.playing')?.classList.remove('playing');
                    }
                }, duration * 1000);
            }
        }

        // Volume management with persistence
        function initializeVolume() {
            const masterVolume = document.getElementById('masterVolume');
            const volumeLabel = document.getElementById('volumeLabel');
            
            // Try to load saved volume preference, default to 0.8 for better audibility
            const savedVolume = localStorage.getItem('sleepSoundsVolume');
            const defaultVolume = savedVolume ? parseFloat(savedVolume) : 0.8;
            
            masterVolume.value = defaultVolume;
            updateVolumeDisplay(defaultVolume);
            
            // Apply volume if audio context exists
            if (audioContext && gainNode) {
                gainNode.gain.value = defaultVolume;
            }
        }

        // Update volume display elements
        function updateVolumeDisplay(volume) {
            const volumeLabel = document.getElementById('volumeLabel');
            const speakerIcon = document.querySelector('.volume-container span:first-child');
            
            // Update percentage
            volumeLabel.textContent = Math.round(volume * 100) + '%';
            
            // Update speaker icon based on volume level
            if (volume === 0) {
                speakerIcon.textContent = 'ðŸ”‡';
            } else if (volume < 0.3) {
                speakerIcon.textContent = 'ðŸ”ˆ';
            } else if (volume < 0.7) {
                speakerIcon.textContent = 'ðŸ”‰';
            } else {
                speakerIcon.textContent = 'ðŸ”Š';
            }
        }

        // Handle volume changes
        const masterVolume = document.getElementById('masterVolume');
        masterVolume.addEventListener('input', (e) => {
            const volume = parseFloat(e.target.value);

            // Save volume preference
            localStorage.setItem('sleepSoundsVolume', volume.toString());
            
            // Update display
            updateVolumeDisplay(volume);

            // Only adjust volume if audio context is initialized
            if (audioContext && gainNode) {
                gainNode.gain.value = volume;
            }
        });

        // Add a "Full Volume" button for easy system-relative maximum
        function createVolumeControls() {
            const volumeContainer = document.querySelector('.volume-container');
            
            // Create full volume button
            const fullVolumeBtn = document.createElement('button');
            fullVolumeBtn.innerHTML = 'MAX';
            fullVolumeBtn.style.cssText = `
                background: rgba(255,255,255,0.1);
                border: 1px solid rgba(255,255,255,0.2);
                color: white;
                font-size: 0.8em;
                cursor: pointer;
                padding: 5px 8px;
                border-radius: 5px;
                transition: all 0.2s;
                font-weight: bold;
            `;
            fullVolumeBtn.title = 'Set to maximum volume (100% relative to your device volume)';
            
            fullVolumeBtn.addEventListener('click', () => {
                masterVolume.value = 1.0;
                localStorage.setItem('sleepSoundsVolume', '1.0');
                updateVolumeDisplay(1.0);
                if (audioContext && gainNode) {
                    gainNode.gain.value = 1.0;
                }
            });
            
            fullVolumeBtn.addEventListener('mouseenter', () => {
                fullVolumeBtn.style.background = 'rgba(255,255,255,0.2)';
                fullVolumeBtn.style.transform = 'scale(1.05)';
            });
            
            fullVolumeBtn.addEventListener('mouseleave', () => {
                fullVolumeBtn.style.background = 'rgba(255,255,255,0.1)';
                fullVolumeBtn.style.transform = 'scale(1)';
            });
            
            volumeContainer.appendChild(fullVolumeBtn);
        }

        // Initialize the app
        const soundGrid = document.getElementById('soundGrid');
        sounds.forEach(sound => {
            soundGrid.appendChild(createSoundCard(sound));
        });

        // Initialize volume controls
        initializeVolume();
        createVolumeControls();

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed:', err);
                    });
            });
        }
    </script>
</body>
</html>